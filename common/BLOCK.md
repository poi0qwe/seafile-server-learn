# 块

文件被分块后（采取CDC分块），被存储为块。

## 抽象结构与操作

- ### 块的内容

    块可以抽象为两部分信息：校验和(checksum)和块内信息。

    - 校验和

        SHA1摘要的前160位比特。以16进制串的形式表示，得到20位HEX串。(共40位字符)

    - 块内信息

        块并不关心块内信息，只关心块内信息的存储。在校验块时需要重新对块内信息计算校验和，然后与块的校验和比对，检查块内信息是否被篡改。

- ### 块的元数据

    BMetadata定义了块的元数据，包括：块id、块长。

- ### 块的路径

    依照以下内容定位一个块：

    - block_dir

        存储块的根目录。对外界隐藏。

    - store_id

        仓库存储id。

    - version

        仓库存储版本（开启迁移时有用，尚无实现）。

    - block_id

        块id。

- ### 块操作

    [block-backend.h](https://github.com/poi0qwe/seafile-server-learn/blob/main/common/block-backend.h) 中规定了块操作的抽象接口，包括以下内容：

    1. 打开块

        根据store_id、version、block_id、和操作类型，打开块，然后返回块的句柄。

    2. 读块

        根据句柄，向缓冲写块的内容。

    3. 写块

        根据句柄，将缓冲中的内容写入**临时**块。

    4. 提交

        根据句柄，提交临时块中的内容。用临时块的内容去替换目标块。

    5. 关闭

        根据句柄，关闭块。

    6. 存在

        根据store_id、version、block_id，判断块是否存在。（不用块的句柄说明不需要打开块）

    7. 移除块

        根据store_id、version、block_id，移除一个块。

    8. 获取元数据

        根据store_id、version、block_id，获取块的元数据。

        或根据块的句柄，获取块的元数据。

    9. 释放块的句柄

        释放句柄空间。

    10. 遍历块

        给定store_id和version，并提供用户函数和用户参数，去遍历仓库中的所有块。每访问一个块，向用户函数传入store_id、version、block_id以及用户参数。

    11. 复制快

        提供块A和块B的store_id、version、block_id，将A的内容复制到B；若不存在B则创建。

    12. 移除仓库存储

        移除仓库中的所有块。当且仅当version = 1。

## 基于文件系统的实现

[block-backend-fs.c](https://github.com/poi0qwe/seafile-server-learn/blob/main/common/block-backend-fs.c) 中以文件系统实现了块的后台操作、块的句柄。

- ### 块的存储

    在文件系统实现中，以块文件表示块。

    1. 校验和与块内信息

        校验和被用作文件名与block_id、块内信息即文件内容。

    2. 块的路径

        格式如下：

        ```s
        [block_dir]/[store_id]/[block_id[:2]]/[block_id[2:]]
        ```

        在block_dir下的一个三级目录结构，一级是store_id，二级是block_id的前两位；三级是block_id的后38位。（因为校验和被用作block_id，所以block_id共40位）

- ### 块的句柄

    ```c++
    struct _BHandle { // 句柄
        char    *store_id;      // 仓库id
        int     version;        // 版本
        char    block_id[41];   // 块id
        int     fd;             // 文件标识符
        int     rw_type;        // 读写类型
        char    *tmp_file;      // 临时文件路径，被用于写操作与提交操作
    };
    ```

    其中最主要的就是文件描述符。此后用到块句柄的操作都以此为基础实现。

- ### 基本块文件操作

    1. 合成路径

        提供store_id、version、block_id，合成块文件路径。（block_dir被隐藏在后台私有域中，也参与合成）

    2. 打开临时文件

        临时文件路径就是在块路径的基础上加上了'.XXXXXX'的后缀。打开临时文件同打开块文件。

- ### 块操作

    1. 打开块

        根据store_id、version、block_id生成路径。
        
        如果是读，就以只读方式打开块文件；如果是写，就以可写与创建方式打开临时文件。
        
        最后将相关信息记录到块的句柄。

    2. 读块

        根据文件描述符，读取缓冲。

    3. 写块

        根据文件描述符，写入缓冲至临时文件。

    4. 提交

        用临时文件替换块文件。

    5. 关闭

        根据文件描述符关闭文件。

    6. 存在

        合成路径后，检查文件存在性。

    7. 移除块

        合成路径后，移除文件。

    8. 获取元数据

        合成路径或根据文件描述符，获取文件元数据。

    9. 释放块的句柄

        释放结构体空间。

    10. 遍历块

        合成仓库路径，遍历文件名得到block_id，随后呈递给用户函数。

    11. 复制快

        分别合成两个路径，然后系统调用复制文件。

    12. 移除仓库存储

        当且仅当version = 1。遍历，并移除。

## 块系统封装

除了上述操作外，seafile还封装了以下操作：

1. 获取仓库中块的数量

    利用块遍历操作，获取仓库中块的数量。

2. 验证块

    用块的内容重新计算校验和，与块的校验和（文件系统实现中是block_id）对比，判断块是否被篡改。

## 块传输协议

该部分内容是服务端与客户端共用。

- ### 状态

    ```c++
    enum
    {
        STATUS_OK = 0,                // OK
        STATUS_VERSION_MISMATCH,      // 版本不匹配
        STATUS_BAD_REQUEST,           // 请求错误
        STATUS_ACCESS_DENIED,         // 拒绝访问
        STATUS_INTERNAL_SERVER_ERROR, // 服务器内部错误
        STATUS_NOT_FOUND,             // 未找到
    };
    ``

    seafile有两种加密版本，它们的密钥和iv不一样。

- ### 协议头

    1. 握手请求/响应头

        握手请求：版本、密钥长度、会话密钥。

        握手响应：状态。

    2. 权限请求/响应

        权限请求：暂无。

        权限响应：状态。

    3. 块请求头/响应头

        请求头：命令（GET/PUT）、块id。

        响应头：状态。

- ### 成帧

    一个帧的结构如下：

    |类型|描述|可选性|
    |:-|:-|:-|
    |权限头|权限请求或响应|*|
    |块头|块请求或响应；请求头包含命令|*|
    |块数据|块的内容|仅块响应|

- ### 协议流程

    1. 收方发送握手请求，发方接收握手响应，收方接收权限响应；
    2. 收方发送权限请求、块请求；
    3. 发方发送权限响应、块响应、块内容。

- ### 帧加密

    每个帧都已加密形式被发送。一个加密帧的内容如下：

    |内容|描述|长度|
    |:-|:-|:-|
    |帧长|加密帧总长度|int32|
    |加密数据|加密帧数据，包括所有协议头|帧长|

- ### 缓冲区读帧

    每次从缓冲区中读一个帧的流程如下：

    1. 读取整个缓冲区；
    2. 若帧转化器定长，则读取定长数据，取前四个字节作为帧长，再解码；
    3. 否则直接读前四个字节作为帧长，然后解码后面的数据。

- ### 帧解密

    分为两种解密数据加工方式：

    1. 解密整个帧，回调；（handle_one_frame）
    2. 解密帧，解密帧尾，分别回调。（handle_frame_segments）

    这样划分是因为对称加密需要padding，此时数据被分为两部分，一段是整长部分，另一段是非整长部分。

    如果只需整体处理，则使用第一种方式；如果上述两部分有区别，则使用第二种方式。
